<!DOCTYPE HTML>
<html lang="en-US">
<head>
	<meta charset="UTF-8">
	<title></title>
	<script type="text/javascript" src="./libs/enchant.js"></script>
	<script type="text/javascript" src="./libs/gl-matrix-min.js"></script>
	<script type="text/javascript" src="./libs/gl.enchant.js"></script>
	<script type="text/javascript" src="./libs/primitive.gl.enchant.js"></script>
    <script type="text/javascript" src="./libs/widget.enchant.js"></script>
    <script type="text/javascript" src="./libs/mixing.enchant.js"></script>
    <script type="text/javascript" src="./libs/extension.gl.enchant.js"></script>
    <script type="text/javascript" src="./lib_iq/axis.js"></script>
    <script type="text/javascript" src="./lib_iq/qube.js"></script>
    <script type="text/javascript" src="./lib_iq/floor.js"></script>
    <script type="text/javascript" src="./lib_iq/extendQube.js"></script>
    <script type="text/javascript" src="./lib_iq/player.js"></script>
    <script type="text/javascript" src="./lib_iq/problems.js"></script>
	<script type="text/javascript">

var bearImage    = './images/chara1.png';
var bgImage      = './images/enchant_frame.png';
var bulletImage  = './images/bullet.png';
var eBulletImage = './images/eBullet.png';
var colorsImage  = './images/colors.png';
var stoneImage   = './images/stone.png';
var blueStoneImage = './images/blueStone.png';
var greenStoneImage = './images/greenStone.png';
var blackStoneImage = './images/blackStone.png';
var redStoneImage = './images/redStone.png';
var blueGreenStoneImage = './images/blueGreenStone.png';
var gameClearImage = './images/clear.png';
var gameOverImage = './images/end.png';
var highLightImage = './images/highLight.png';
var shadowImage = "./images/shadow.png";

enchant();
window.onload = function(){
    game = new Core(512, 512);
    game.fps = 30;
    game.preload(gameClearImage, gameOverImage, bearImage, highLightImage);
    game.onload = function () {

//******************************
//  グローバルな状態変数
//******************************
        var gameLevel = 2;//難易度
        var isRandomGame = false;//ランダム生成モードか
   
        var scene;//scene3D
        var cubes = new Array();//キューブ配列
        var floors = new Array();//床面2次元配列
        var floorsCube = new Array();
        var player;//プレイヤーモデル

        //ゲーム内に残っているキューブの数
        var lestNormalCube = 0;
        var lestAdvantageCube = 0;
        var lestForbiddenCube = 0;

        //ゲームスピード
        //rollFrame *n = rollCycleにしておかないと残キューブ数の取得で0を出す
        var rollFrame = 15;//90度回転にかかるフレーム数
        var rollCycle = 30;//回転から次の回転までの周期
        
        //ボタン押下多重判定防止
        upButtonStack = 0;
        downButtonStack = 0;
        rightButtonStack = 0;
        leftButtonStack = 0;
        aButtonStack = 0;
        bButtonStack = 0;

        var isGameMode = false; //カメラの動き追従用フラグ(ステージ開始時の動き)

        var floorLength = 20;//床の最初の長さ

//******************************
//  キーバインドの設定
//******************************
 //-----キーイベントの生成
        var initUI = function(){
            game.keybind(90, 'a');// zキー  
		    game.keybind(88, 'b');// xキー  
		    game.keybind(67, 'c');// cキー  

            //プレイヤー操作時に、一度のボタン押下で一度だけ行う処理のためのフラグを生成するイベント
//カーソルキースタック
            game.addEventListener('upbuttonup', function(){
                upButtonStack = 0;
            });
            game.addEventListener('downbuttonup', function(){
                downButtonStack = 0;
            });
            game.addEventListener('rightbuttonup', function(){
                rightButtonStack = 0;
            });
            game.addEventListener('leftbuttonup', function(){
                leftButtonStack = 0;
            });
//ボタンスタック
            game.addEventListener('abuttondown', function(){
                console.log("abuttondown");
            })
            game.addEventListener('abuttonup', function(){
                aButtonStack = 0;//初期化
                console.log("abuttonup");
            })
            game.addEventListener('bbuttondown', function(){
                console.log("bbuttondown");
            })
            game.addEventListener('bbuttonup', function(){
                bButtonStack = 0;
                console.log("bbuttonup");
            })
        }

//-----ゲーム開始画面で使うオブジェクト

//******************************
//  スタート画面
//******************************
//-----ゲーム開始メニューとコンフィグの生成
        var initStartMenu = function(){
            //メニューラベルのクラス定義
            var Menu = enchant.Class.create(enchant.Label,{
                initialize: function(scene, y, text){
                    enchant.Label.call(this);
                    this.x = 256;
                    this.y = y;
                    this.font = "30px bold sans";
                    this.color = "red";
                    this.text = text;
                    scene.addChild(this);
                    this.x -= this._boundWidth/2;//中央揃え(addchildより先だと_boundWidhtはdef:1なので機能しない)
                }
            });
            
            var labelOpacity = 1;
//-----ユーティリティ
            var moveToGame = function(){
                 game.popScene();//シーンを戻してからゲーム画面に遷移
                initializeGame();           
            }
            var moveToConfig = function(){
                focusStartMenu = 1;
                focusConfigMenu = 0;
                startScene.tl.moveBy(-512, 0, 15, enchant.Easing.QUAD_EASEINOUT).then(function(){
                    game.transitionPush(configScene);
                });
            }
//-----スタートメニュー画面
            var startScene = new Scene(512, 512);
            startScene.backgroundColor = "black";

            //難易度変数に応じたゲームを開始する
            var startButton = new Menu(startScene, 200, "START");
            startButton.addEventListener('touchstart', function(){
                moveToGame();
            })

            //設定画面へ遷移
            var configButton = new Menu(startScene, 400, "CONFIG");
            configButton.addEventListener('touchstart', moveToConfig);

            game.pushScene(startScene);

//-----スタート画面でのキーイベント実装
            var focusStartMenu = 0;//メニューでキー操作するためのフォーカス情報
            startScene.addEventListener('enterframe', function(){
//カーソルキーの動作
                if(game.input.up && (upButtonStack == 0)){
                    focusStartMenu--;
                    upButtonStack = 1;
                }else if(game.input.down && (downButtonStack == 0)){
                    focusStartMenu++;
                    downButtonStack = 1;
                }
//決定ボタンの動作
                if(game.input.a && (aButtonStack == 0)){
                    if(focusStartMenu % 2 == 0){
                        moveToGame();
                    }else if(focusStartMenu % 2 == 1){
                        moveToConfig();
                    }
                    aButtonStack = 1;
                }
            })
//-----スタート画面でのフォーカス表示スプライト
            var fSMS = new Sprite(32,32);
            fSMS.x = 150;
            fSMS.y = 200;
            fSMS.image = game.assets[bearImage];
            startScene.addChild(fSMS);
            fSMS.addEventListener('enterframe', function(){
                if(focusStartMenu % 2 == 0){
                    this.y = 200;
                }else if(focusStartMenu % 2 == 1){
                    this.y = 400;
                }
            })

//******************************
//  コンフィグ画面
//******************************
//-----設定メニュー画面
            //座標テーブル
            var m02 =  50;
            var m11 = 100;
            var m12 = 150;
            var m21 = 200;
            var m22 = 250;
            var m31 = 300;
            var m32 = 350;
            var m41 = 400;

            var configScene = new Scene(512, 512);
            configScene.backgroundColor = "black";

            var focusRim = new Sprite()
            
            //モード表示ラベル
            var gameMode = new Menu(configScene, m02, "GAMEMODE");
            gameMode.addEventListener('touchstart', function(){
                focusConfigMenu = 0;
            })

            //モードハイライトのスプライト
            var modeH = new Sprite(32,32);
            modeH.x = 145;
            modeH.y = m11;
            modeH.scaleX = 6;
            modeH.image = game.assets[highLightImage];
            modeH.opacity = 0.5;
            configScene.addChild(modeH);

            //選択モード（ノーマル）のラベル
            var normalMode = new Menu(configScene, 100, "NORMAL");
            var normalModeTouchEvent = function(){
                focusConfigMenu = 0;
                isRandomGame = false;
                modeH.tl.tween({
                   x: 145,
                   y: m11,
                   scaleX: 6,
                   scaleY: 1,
                   time: 10,
                   easing: enchant.Easing.QUART_EASEOUT
               });
            };
            normalMode.x = m11;
            normalMode.addEventListener('touchstart', normalModeTouchEvent);


            //選択モード（ランダム）のラベル
            var randomMode = new Menu(configScene, m11, "RANDOM");
            var randomModeTouchEvent = function(){
                focusConfigMenu = 0;
                isRandomGame = true;
                modeH.tl.tween({
                    x: 345,
                    y: m11,
                    scaleX: 6,
                    scaleY: 1,
                    time: 10,
                    easing: enchant.Easing.QUART_EASEOUT
                });
            };
            randomMode.x = 300;
            randomMode.addEventListener('touchstart', randomModeTouchEvent);


            //難易度表示ラベル
            var difficulty = new Menu(configScene, m12, "DIFFICULTY");
            difficulty.addEventListener('touchstart', function(){
                focusConfigMenu = 1;
            })

            //難易度ハイライトのスプライト
            var levelH = new Sprite(32,32);
            levelH.x = 256 - 16 + (gameLevel - 3) * 40;
            levelH.y = m21;
            levelH.image = game.assets[highLightImage];
            levelH.opacity = 0.5;
            configScene.addChild(levelH);

            //難易度を5段階で表示
            for(var i=0;i<5;i++){
                var level = new Menu(configScene, m21, ""+(i+1));
                level.x += (i-2) * 40;
                level.diffNum = i+1;
                level.addEventListener('touchstart', function(){
                    focusConfigMenu = 1;
                    gameLevel = this.diffNum;
                    levelH.tl.moveTo(256 - 16 + (gameLevel - 3) * 40, m21, 5, enchant.Easing.QUAD_EASEOUT);

                })
            }
            //引数で難易度を変更する処理
            var levelTouchEvent = function(num){
                focusConfigMenu = 1;//一応入れておく
                if(num <= 0){num += 5};
                gameLevel = num;
                levelH.tl.moveTo(256 - 16 + (gameLevel - 3) * 40, m21, 5, enchant.Easing.QUAD_EASEOUT);
                console.log("gameL: "+ gameLevel);
            }
            
            //ゲームスピード表示ラベル
            var difficulty = new Menu(configScene, m22, "SPEED");
            difficulty.addEventListener('touchstart', function(){
                focusConfigMenu = 2;
            })
        
             //スピードハイライトのスプライト
            var speedH = new Sprite(32,32);
            speedH.x = 145;
            speedH.y = m31;
            speedH.scaleX = 6;
            speedH.image = game.assets[highLightImage];
            speedH.opacity = 0.5;
            configScene.addChild(speedH);  

             //スピード等倍のラベル
            var normalSpeedMode = new Menu(configScene, m31, "NORMAL");
            var normalSpeedModeTouchEvent = function(){
                focusConfigMenu = 2;
//                isRandomGame = false;
                speedH.tl.tween({
                   x: 145,
                   y: m31,
                   scaleX: 6,
                   scaleY: 1,
                   time: 10,
                   easing: enchant.Easing.QUART_EASEOUT
               });
            };
            normalSpeedMode.x = 100;
            normalSpeedMode.addEventListener('touchstart', normalSpeedModeTouchEvent);           

             //スピード2倍のラベル
            var doubleSpeedMode = new Menu(configScene, m31, "DOUBLE");
            var doubleSpeedModeTouchEvent = function(){
                focusConfigMenu = 2;
//                isRandomGame = false;
                speedH.tl.tween({
                   x: 345,
                   y: m31,
                   scaleX: 6,
                   scaleY: 1,
                   time: 10,
                   easing: enchant.Easing.QUART_EASEOUT
               });
            };
            doubleSpeedMode.x = 300;
            doubleSpeedMode.addEventListener('touchstart', doubleSpeedModeTouchEvent);   


            //戻るラベル
            var back = new Menu(configScene, m41, "BACK");
            var backTouchEvent = function(){
                focusConfigMenu = 3;
                configScene.tl.moveBy(512,0, 15, enchant.Easing.QUAD_EASEINOUT).then(function(){
                    game.popScene();
                    startScene.x=0;
                    startScene.x = -512;
                    startScene.tl.delay(1).then(function(){
                        startScene.tl.moveTo(0,0,15, enchant.Easing.QUAD_EASEINOUT);

                        configScene.x=0;//init Fix position
                    })
                })
            };
            back.addEventListener('touchstart', backTouchEvent);

//-----設定画面でのフォーカス表示スプライト(くま)
            var fCMS = new Sprite(32,32);
            fCMS.x = 120;
            fCMS.y = m21;
            fCMS.image = game.assets[bearImage];
            configScene.addChild(fCMS);

            fCMS.addEventListener('enterframe', function(){
                frag = focusConfigMenu % 4;
                if(frag == 0){
                    this.x = 120;
                    this.y = m02;
                }else if(frag == 1  || frag == (-3)){
                    this.x  =120;
                    this.y = m12;
                }else if(frag == 2 || frag == (-2)){
                    this.x = 160;
                    this.y = m22;
                }else if(frag == 3 || frag == (-1)){
                    this.x = 160;
                    this.y = m41;
                }
            })

//-----設定画面でのキーイベント実装
            var focusConfigMenu = 0;//メニューでキー操作するためのフォーカス情報
            var frag = focusConfigMenu % 3;
            configScene.addEventListener('enterframe', function(){
            frag = focusConfigMenu % 3;
//-----カーソルキーの動作
                if(game.input.up&& (upButtonStack == 0)){
                    focusConfigMenu--;
                    upButtonStack = 1;
                }else if(game.input.down && (downButtonStack == 0)){
                    focusConfigMenu++;
                    downButtonStack = 1;
                }else if(game.input.left && (leftButtonStack == 0)){
                    if(frag == 0){
                         if(isRandomGame == true){
                            normalModeTouchEvent();
                        }else if(isRandomGame == false){
                            randomModeTouchEvent();
                        }                   
                    }else if(frag == 1 || frag == (-2)){
                        levelTouchEvent( (gameLevel) % 5 - 1 );
                    }
                    leftButtonStack = 1;
                }else if(game.input.right && (rightButtonStack == 0)){
                    if(frag == 0){
                         if(isRandomGame == true){
                            normalModeTouchEvent();
                        }else if(isRandomGame == false){
                            randomModeTouchEvent();
                        }                   
                    }else if(frag == 1 || frag == (-2)){
                        levelTouchEvent( (gameLevel) % 5 + 1 );
                    }
                    rightButtonStack = 1;
                }
//-----ボタンの動作
                if(game.input.a && (aButtonStack == 0)){
                    if(frag== 0){
                        if(isRandomGame == true){
                            normalModeTouchEvent();
                        }else if(isRandomGame == false){
                            randomModeTouchEvent();
                        }                    
                    }else if(frag == 1 || frag == (-2)){
//                        levelTouchEvent( (gameLevel) % 5 +1 );
                    }else if(frag == 2){
                        backTouchEvent();
                    }
                
                    aButtonStack = 1;    
                }else if(game.input.b && (bButtonStack == 0)){
                        backTouchEvent();
                    bButtonStack = 1;
                }
            })
        }


//******************************
//  ゲーム本体の3D用部品
//******************************
//-----ゲーム本体で使うオブジェクト

//-----GUI部品生成クラス


//******************************
        //シーンとカメラの設定
//******************************
        var createScene3d = function (){
             //シーン空間生成
            scene = Scene3D();
            scene.backgroundColor = [0.1, 0.2, 0.25, 1];
            //カメラ初期位置の設定
            var camera = scene.getCamera();
            camera.x = 0;//0.5 - initCubeArray.length/2 -1;
            camera.y = 30 + (initCubeArray.length-4)*6;
            camera.z = 55 + (initCubeArray.length-4)*10;

            //カメラの挙動
            game.addEventListener('enterframe',function(){
                if(isGameMode){
                    camera.x += (player.x * 5 - camera.x) / 5;//プレイヤーの動きに合わせてカメラを動かす
                    camera.y = 30 + (initCubeArray.length-4)*6;
                    camera.z = 55 + (player.z)/1 -7 + (initCubeArray.length-4)*5;
    //                camera.centerZ = 0 + (player.z - 14)/2;
                    camera.centerZ = -10 + (player.z)/1 -7  + (initCubeArray.length-4)*5;
                }
            })


            var light = new DirectionalLight(); // 平行光源生成
            light.directionZ = 1;               // 向き
            light.directionY = 1;
            light.color = [0.3, 0.3, 0.3];      // 色
            scene.setDirectionalLight(light);   // scene にセット
        }

//******************************
//2DスプライトのUI部品を生成
//******************************
        var createScene2d = function(){
                //フレームレートを表示
                var lastDate = new Date;
                var param = new Label("");
                param.x = 15;
                param.y = 5;
                param.font = "50px bold sans";
                param.text = "0 fps";
                param.color = "black";
                game.rootScene.addChild(param);
                param.onenterframe = function(){
                    var thisDate = new Date;
                    framedata = Math.round(1000 / (thisDate - lastDate));
                    lastDate = thisDate;
                    param.text = framedata+"/"+game.fps+ " fps";
                };

        }
        var createSprite = function(){
            var sp = new Sprite(200,100);
            sp.x = 125;
            sp.y = -100;
            sp.image = game.assets[gameClearImage];
            game.rootScene.addChild(sp);
            sp.onenterframe = function(){
                this.y+=2;
                if(this.y> 300){
                    this.removeEventListener('enterframe', arguments.callee);
                }
            }
        };

//******************************
//ゲーム導入時にキューブが隆起するエフェクトを発生させる処理
//******************************
        var createStageIntroduction = function(array, createFunc){
            //隆起する秒数はキューブ配列長による
            var counter = array.length *15;
            var hoge = new Sprite(1,1);//適当なイベントリスナ
            game.rootScene.addChild(hoge);//nodeに加える
            //カウンタ数だけゲーム開始を遅らせる
            hoge.addEventListener('enterframe', function(){
                counter--;//カウンタ減算
                console.log(counter);
                if(counter < 0){
                    //-----カウンタが終了したらゲーム開始処理を呼ぶ
                    //ゲーム用キューブ、イベントハンドラーを生成
                    createFunc(array);
                    initGameHandler();
                    //カメラをゲームモードにする
                    isGameMode = true;
                    //隆起用キューブは捨てる
                    for(var i=0;i<introCubes.length;i++){
                        scene.removeChild(introCubes[i]);
                        introCubes[i].removeEventListener('enterframe', arguments.callee);
                        delete introCubes[i];
                    }
                    introCubes = new Array();//キューブ配列を初期化
                    hoge.removeEventListener('enterframe', arguments.callee);//リスナーを初期化
                    hoge=null;
                }
            });
            
            var introCubes = new Array();
            //隆起するキューブを生成
            var margin = 2;
            for(var i=0;i<array.length;i++){
                for(var j=0;j<array[i].length;j++){
                    var cube = new NormalQube();
                    cube.x = (j - array[0].length/2) *margin + 1;
                    cube.y = -1 - i;
                    cube.z = i *margin;
                    scene.addChild(cube);
                    introCubes.push(cube);
                    cube.addEventListener('enterframe', function(){
                       this.y += 0.1;
                       if(this.y >= 0){
                            this.removeEventListener('enterframe', arguments.callee);
                        } 
                    });
                }
            }
            //導入中のカメラの挙動制御
            var introCamera = scene.getCamera();
            introCamera.x = 10;
            introCamera.y = 1;
            introCamera.z = 0;
            introCamera.centerZ = 0;
            hoge.addEventListener('enterframe', function(){
                introCamera.x += (0 - introCamera.x) /20;
                introCamera.y += (30 + (array.length-4)*6 - introCamera.y)/20;
                introCamera.z += ( (55 + (player.z)/1 -7 + (array.length-4)*5 ) - introCamera.z)/20;
            });
        }

//******************************
        //キューブ配列を生成
//******************************
        var createCubeArray = function(){
            if(isRandomGame){
                initCubeArray = randomCubeArray(gameLevel+2,gameLevel+3);
            }
        }


//******************************
        //座標軸を生成
//******************************
        var createAxis = function(){
//           var axis = new Axis(scene);
        }

//******************************
        //床面を生成
//******************************
        var createFloor = function(array){
            var scale = 1;
            var margin = 2;
            var texture = new Texture();

            for(var i=0;i<array[0].length;i++){
                floors[i] = new Array();
                floorsCube[i] = new Array();
                for(var j=0;j<floorLength;j++){ //array[i].lengthではフィールドにならない
                    var plane = new Floor(scale);
                    plane.x =  (i - array[0].length/2) * scale * margin + 1; 
                    plane.y = -1;
                    plane.z =  j * scale * margin;
                    plane.arrayNumX = i;//配列上の位置を持たせる（popでは変化しない）
                    plane.arrayNumY = j;
                    plane.parentArray = floors;//親配列を持たせる
                    scene.addChild(plane);
                    floors[i].push(plane);

                    //足場の石柱を作る
                    //外周だけ
                    for(var k=0;k<1;k++){//三段
//                        if( ((i==0) || (i==array[0].length-1)) || ((j==0) || (j==floorLength-1)) ){
                        if(true){
                            var footCube = new FloorQube(floorsCube);
                            footCube.x =  (i - array[0].length/2) * scale * margin + 1;
                            footCube.y = -2 * (k+1) -0.05;//床より若干下げる
                            footCube.z = j * margin;

                            footCube.arrayNumX = i;//配列上の位置を持たせる（popでは変化しない）
                            footCube.arrayNumY = j;

                            scene.addChild(footCube);
                            floorsCube[i].push(footCube);
                        }
                    }

                }
            }
        }


//******************************
        //キューブ群を生成
//******************************
        var createCubes = function (array){

            var margin = 2;
            for(var i=0;i<array.length;i++){
                for(var j=0;j<array[i].length;j++){
                    if(array[i][j] == 2){
                        var cube = new ForbiddenQube();
                        cube.parentFloor = floors;
                        cube.parentFloorCube = floorsCube;//FBDの場合は配列を追加で持たせる
                        cube.parentScene = scene;
                        lestForbiddenCube++;
                    }else if(array[i][j] == 1){
                        var cube = new AdvantageQube();
                        lestAdvantageCube++;
                    }else{
                        var cube = new NormalQube();
                        lestNormalCube++;
                    }
                    cube.x = (j - array[0].length/2) *margin + 1;
                    cube.y = 0;
                    cube.z = i *margin;
                    scene.addChild(cube);
                    cubes.push(cube);//配列に組み込む
                    cubes.parentArray = cubes;//子から親が読めるようにしておく
                }
            }
        };

//******************************
        //プレイヤーモデルを生成
//******************************
        var createPlayer = function(){
            player = new Player();
            //playerクラスの矩形当たり判定の取り方と一歩の間隔で
            //床面の境目に入り込むと判定に齟齬があるため、小数点座標に配置する
            player.x = 0.1 ;
            player.y = 1.1;
            player.z = 14 + initCubeArray.length;
            scene.addChild(player);
        }

        //ゲームクリアスプライトを表示
        var createGameSprite = function(message){

        }


//-----init UI
//******************************
        //画面表示部品の生成関数をまとめる
//******************************
        var init3dGUI = function(cubeArray){
            createCubeArray();
            createScene3d();
            createScene2d();
            createAxis();
            createFloor(cubeArray);
            createPlayer();
            createStageIntroduction(cubeArray, createCubes);
//            createCubes(cubeArray);
        };

//-----イベントコントロールハンドラ
//******************************
        //動作タイミングの管理、キーイベント、フラグなどの管理イベントの生成
//******************************
        var initGameHandler = function(){
            var time = 0; //キューブの回転タイミングを管理
            var enableDeleteCube = false; //[フラグ]回転停止時ごとに1度だけマーカー解除からキューブを削除できる(回転動作中に削除させない)
            var lestTimeCounter = 0;//何らかの演出などを処理している間は、新しい回転動作を行わない。

//-----キーバインドの追記
//            game.addEventListener('abuttonup', function(){
//                player.aButtonStack = 0;//初期化
//            })
//            game.addEventListener('bbuttonup', function(){
//                player.bButtonStack = 0;
//            }) 


//-----毎フレームの基本ロジック処理
            game.addEventListener('enterframe', function(){
                //プレイヤーの載っている床面を更新
//                player.getStayFloor(floors);
//
//                //崩れた床に乗っていればゲームオーバー判定
                    if(time > rollCycle){
                        if(player.stayFloor.isBroken == true){
                            console.log("stamped!!");
                            player.stamped();
                            this.removeEventListener('enterframe', arguments.callee);
                        }
                    }
                //半ターンに1度床面とキューブの走査を行う(密に行うほど精緻な判定になるが処理に影響する)(回転が停止し、enableが有効になるタイミング、回転開始にタイミング)
                if(time % rollFrame == 0){
                    refleshFloorsRelation();//状態の更新

                    //回転が止まったタイミング
                    if(time % rollCycle != 0){
//                        console.log("enable: "+enableDeleteCube +", change to true." + "time: "+time +", ");
                        //回転が止まったタイミングでキューブを消せる状態変数に置き換える
                        enableDeleteCube = true;

                        //プレイヤーとキューブが同じ床面にいれば押しつぶし判定してゲーム終了
                        if(player.stayFloor.targetCube != null){
                            console.log("stamped!!");
                            player.stamped();
//                            lestTimeCounter = 10000;
                            this.removeEventListener('enterframe', arguments.callee);
                        }
                    }

                }
                //30フレームに1度回転処理を呼び出す
                if(time % rollCycle == 0 ){
                    //回転中はマーカー解除してもキューブを捕獲できない
                    enableDeleteCube = false;
                    //15フレームで90度回転させる指示を与える
                    for(var i=0;i<cubes.length;i++){
                        cubes[i].roll(90,rollFrame);
                    }

                }
                //1フレーム早く状態を変更する（回転開始と削除のバッティング防止）
                if(time % rollCycle <= 1){
                    enableeleteCube = false;
                }

                //削除演出中で無ければカウンタを回す
                if(lestTimeCounter <= 0){
                    time++;
                }else{
                    lestTimeCounter -= 1;
                }

                //キューブ削除された場合に、キューブが沈んだタイミングで床面との関係を更新する（playerを歩かせる為）
                if(lestTimeCounter == rollFrame *2 - 8){
                    refleshFloorsRelation();
                    console.log("lestTime: "+lestTimeCounter);
                }

            })

//******************************
//-----カーソルキー入力へのアクション
//******************************

//-----プレイヤーのアクション
            //一度の押下で何度も行う処理
            player.addEventListener('enterframe', function(){
                //移動前の座標を保存
                this.bx = this.x;
                this.bz = this.z;
                this.bStayFloor = this.stayFloor;

                if(this.isStamped == false){
                    
                    if (game.input.left){
                        this.x -= 1.5/5;
                    };
                    if (game.input.right){
                        this.x += 1.5/5;
                    };  
                    if (game.input.up){
                        this.z -= 1.5/5;
                    };  
                    if (game.input.down){
                       this.z += 1.5/5;
                    };
                };
                 //移動結果に基づいて床面との関係を更新
                 this.getStayFloor(floors);
                //もし前のフレームと違う床面に載っていた場合、かつ、回転中でない場合
                 if(this.bStayFloor != this.stayFloor && (time % rollCycle > rollFrame) ){
                    //新しいフレームにキューブが載っていたら
                    if(this.stayFloor.targetCube != null){
                        //動作を差し戻す
                        this.x = this.bx;
                        this.z = this.bz;

                        //座標を戻して積載関係を更新する
                        this.getStayFloor(floors);
                    }
                }
                //ステージ外に出ていた場合
                if( (floors[0][0].x -1 > player.x ) 
                    || (floors[floors.length-1][floors[0].length-1].x +1 < player.x ) ) {
                    console.log("out!");
                    this.x = this.bx;
                }
                if((floors[0][0].z -1 > player.z )
                    || (floors[floors.length-1][floors[0].length-1].z +1 < player.z ) ){
                    //差し戻し
                    console.log("out!");
                    this.z = this.bz;
                }

//******************************
//-----ボタン入力へのアクション
//******************************
                 //z
                 //一度の押下で一度だけ行う処理
                 if(game.input.a && (aButtonStack == 0) ){
                     if(time % rollCycle > rollFrame){//キューブが静止している状態のとき
                     refleshFloorsRelation();//床面の参照状態を更新する
                     }

                    //マーカーをセットする
                     if(this.markedFloor == null){
                         //マーカーを貼った床面を保持する
                         this.markedFloor = this.stayFloor;
                         //床面にマーカーをセットする
                         this.stayFloor.isMarker = !this.stayFloor.isMarker;

                    //マーカーを解除する
                     }else{
                        this.markedFloor.isMarker = !this.markedFloor.isMarker;//マークした床面をノーマークに戻す
                        //まだキューブを消していない、かつ、回転中でない
                        if(enableDeleteCube){
//                            console.log("solve Marker");
                            this.markedFloor.solveMarker(); //マーカー解除処理を呼ぶ

                            //マーカー解除した床面にキューブが載っていれば、処理を呼ぶ
                            if(this.markedFloor.targetCube != null){
                                lestTimeCounter =  rollFrame *2;//キューブを削除したら30フレーム待機してから次の回転を始める
                                //キューブが消えたらフラグを戻すイベントリスナを生成
                                this.markedFloor.targetCube.addEventListener('enterframe', function(){
                                   if(this.y  > 90){
                                        this.removeEventListener('enterframe', arguments.callee);
                                    }
                                })
                            }
                            enableDeleteCube = false;//一度の回転停止時のタイミングで、マーカー解除では複数回消せないようにしておく

                        //回転中にマーカー解除した場合、解除フラグを床に設置する
                        }else if( (time % rollCycle < rollFrame) && (time % rollFrame != 0) && !enableDeleteCube){//回転中で、停止中でない
//                            console.log("回転中マーカー解除");
                            this.markedFloor.isReadySolved = true;
                            
                        }
                        this.markedFloor = null;//保持していた床面を破棄
                    }

                     aButtonStack = 1;//フラグを進める
                 }

                 //ｘ
                 //一度の押下で一度だけ行う処理
                 if(game.input.b && (bButtonStack == 0)&& ( time % rollCycle > rollFrame) ){ //ボタン押下時で、一押下で一回起動するもので、回転まで時間がある
                    //起爆マークがあるときにxボタンを押したとき
                    //すべて床を走査して起爆マークのある床面を探す
                    refleshFloorsRelation();//床面の参照状態を更新する
                    
                    var markedFloors = new Array(); //起爆する床面全て
                    var baseMarkedFloors = new Array(); //基点の床面
                    
                    for(var i=0;i<floors.length;i++){
                        for(var j=0;j<floors[i].length;j++){
                            //床面にマークがあった場合
                            if(floors[i][j].isAdvMarked){

                                lestTimeCounter =  rollFrame *2;//rollFrame + rollCycle;//キューブを削除したら45フレーム待機してから次の回転を始める、起爆エリア表示にカウンタを利用する場合は30以上
                                console.log("AdvMark bomb");
                                baseMarkedFloors.push(floors[i][j]); //基点のフラグを解除するためにスタックに保存する
                                //周辺3x3に対してsolveMarkerを呼び出す
                                for(var k=0;k<3;k++){
                                    if( (i+k-1)>-1  && (i+k-1)< floors.length){ //負のインデックスは呼ばない
                                        for(var l=0;l<3;l++){
                                            if( (i+k-1)>-1 && (j+l-1)>-1 ){ //負のインデックスは呼ばない
                                                if(floors[i+k-1][j+l-1] != undefined){ //床面が存在しなければ呼ばない
                                                    //キューブ保護テクニック用ロジック
                                                    if(!floors[i+k-1][j+l-1].isMarker){ //マーカー保護された床面は起爆しない
                                                        markedFloors.push( floors[i+k-1][j+l-1] ); //起爆すべき床面の配列に格納する
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                    //格納された起爆する予定の床面にsolveMarkerを呼び出す
                    for(var i=0;i<markedFloors.length;i++){

//                    markedFloors[i].solveMarker();//即座に起爆する場合
                        //起爆エリア表示後に、一拍待ってから起爆処理を行う
                        markedFloors[i].advTimer = 10; //エリア表示する時間量のカウンタを起動
                        markedFloors[i].isAdvCounted = true;
                        //カウンタを減算し0になったらテクスチャを戻してsolveを行う
                        markedFloors[i].addEventListener('enterframe', function(){
                            this.advTimer -= 1;
                            if(this.advTimer < 0){
                                this.removeEventListener('enterframe', arguments.callee);
                                this.advTimer = null;
                                this.isAdvCounted = false;
                                this.solveMarker();
                                lestTimeCounter = rollFrame *2;
                            }
                        })
                    }

                    markedFloors = null;//配列を捨てる

                    //起爆の基点になった床面のAdvフラグを解除する
                    for(var i=0;i<baseMarkedFloors.length;i++){
                        baseMarkedFloors[i].isAdvMarked = false;
                    }
                    baseMarkedFloors = null;//配列を捨てる

                    bButtonStack = 1; //フラグを進める
                 }
            })

//-----ユーティリティ
//******************************
        //床面とキューブの参照関係を更新する
//******************************
            var refleshFloorsRelation = function(){
                lestForbiddenCube=0;
                lestAdvantageCube=0;
                lestNormalCube=0;

//            var readySolvedFloors = new Array(); //回転終了のタイミングで、マーク解除待機のフラグがある床面にsolveMarkerを送るための床面リスト
                for(var i=0;i<floors.length;i++){
                    for(var j=0;j<floors[i].length;j++){
                        var isCarry = floors[i][j].checkOn(cubes);//積載しているキューブのtypeが返る、床とキューブの参照状態の更新が行われる
                        
                        if(isCarry == 0){//ノーマルキューブが載っている
                            lestNormalCube++;
                        }else if(isCarry == 1){
                            lestAdvantageCube++;
                        }else if(isCarry == 2){
                            lestForbiddenCube++;
                        }else if(isCarry == 10){
                            //何も載っていない
                        }else{
                            //想定外の返り値
                        }

                        //回転終了のタイミングで、解除待機の床面があれば解除してsolveを送る
                        //n個消しを実現するための処理
                        //本当はreslTimeの付与などが必要
                        if(floors[i][j].isReadySolved == true){
                            if(floors[i][j].targetCube != null){
                                floors[i][j].solveMarker();
                                lestTimeCounter = rollFrame *2;
                            }
                            //回転が止まったタイミングでlestTimeを付与すると、enable=true条件に合致してしまうため
                            //キューブの内側に入ればマーク&解除が繰り返せる。これを防ぐためtimeを繰り上げて条件を回避する。
                            time++;
                        }
                        floors[i][j].isReadySolved = false;//フラグ解除
                    }
                }
//            console.log("N: "+ lestNormalCube + ", A :"+ lestAdvantageCube + ", F: " + lestForbiddenCube + " || enable: " + enableDeleteCube + "|| time: " + time + "|| lest: " +lestTimeCounter );
                if(lestNormalCube + lestAdvantageCube + lestForbiddenCube == 0){
                    refleshGame();
                }
            };
        }

//-----reflesh
//******************************
        //次のステージのためにゲームを終了させる初期化処理(床は残る)
//******************************
        //主にinitGameHandlerの外側にある環境変数・参照の解除、initGameHandlerの破棄、状態の初期化
        var refleshGame = function(){
            //キューブと床面の配列を初期化
            for(var i=0;i<cubes.length;i++){
                scene.removeChild(cubes[i]);
                cubes[i].removeEventListener('enterframe', arguments.callee);
                delete cubes[i];
            }
            cubes = new Array();
//            for(var i=0;i<floors.length;i++){
//                for(var j=0;j<floors[i].length;j++){
//                scene.removeChild(floors[i][j]);
//                floors[i][j].removeEventListener('enterframe', arguments.callee);
//                delete floors[i][j];
//                }
//            }
//            floors = new Array();

            //init3dGUIの真似
            createCubes(initCubeArray);
//            createFloor(initCubeArray);
//            床幅が変わるステージ遷移する場合のための処理も用意しておくこと
            
            
        }

//-----initializeGame
//******************************
        //ゲーム本体の初期化処理をまとめて記述
//******************************
        var initializeGame = function (){

//            init3dGUI(initCubeArray);//画面部品を生成
            init3dGUI(randomCubeArray(gameLevel+2,gameLevel+3) );//画面部品を生成
        };

//******************************
//ゲーム開始
//******************************
        initUI();//入力系の実装
        initStartMenu();//スタートメニュー生成
    }
    game.start();
}
</script>
<style type="text/css">
    body {
        margin: 0;
    }
</style>
<body>
</body>
</html>

