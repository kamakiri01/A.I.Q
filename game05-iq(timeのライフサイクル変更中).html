<!DOCTYPE HTML>
<html lang="en-US">
<head>
	<meta charset="UTF-8">
	<title></title>
	<script type="text/javascript" src="./libs/enchant.js"></script>
	<script type="text/javascript" src="./libs/gl-matrix-min.js"></script>
	<script type="text/javascript" src="./libs/gl.enchant.js"></script>
	<script type="text/javascript" src="./libs/primitive.gl.enchant.js"></script>
    <script type="text/javascript" src="./lib_iq/axis.js"></script>
    <script type="text/javascript" src="./lib_iq/qube.js"></script>
    <script type="text/javascript" src="./lib_iq/floor.js"></script>
    <script type="text/javascript" src="./lib_iq/extendQube.js"></script>
    <script type="text/javascript" src="./lib_iq/player.js"></script>
	<script type="text/javascript">

var bearImage    = './images/chara1.png';
var bgImage      = './images/enchant_frame.png';
var bulletImage  = './images/bullet.png';
var eBulletImage = './images/eBullet.png';
var colorsImage  = './images/colors.png';
var stoneImage   = './images/stone.png';
var blueStoneImage = './images/blueStone.png';
var greenStoneImage = './images/greenStone.png';
var blackStoneImage = './images/blackStone.png';

enchant();
window.onload = function(){
    game = new Core(512, 512);
    game.fps = 20;
    game.preload(bearImage, bgImage, bulletImage, eBulletImage);
    game.onload = function () {
   
        var scene;//scene3D
        var cubes = new Array();//キューブ配列
        var floors = new Array();//床面2次元配列
        var player;//プレイヤーモデル

//-----GUI部品生成クラス
        //シーンとカメラの設定
        var createScene3d = function (){
             //シーン空間生成
            scene = Scene3D();
            scene.backgroundColor = [0.1, 0.2, 0.25, 1];
            //カメラ初期位置の設定
            var camera = scene.getCamera();
            camera.x = 0.5;
            camera.y = 20;
            camera.z = 55;

            game.addEventListener('enterframe',function(){
                camera.x += (player.x * 5 - camera.x) / 5;//プレイヤーの動きに合わせてカメラを動かす
                camera.z = 55 + (player.z)/2;
                camera.centerZ = 0 + (player.z - 14)/2;
            })


            var light = new DirectionalLight(); // 平行光源生成
            light.directionZ = 1;               // 向き
            light.directionY = 1;
            light.color = [0.3, 0.3, 0.3];      // 色
            scene.setDirectionalLight(light);   // scene にセット
        }

        //キューブ群を生成
        var createCubes = function (){
            var margin = 2;
            for(var i=0;i<4;i++){
                for(var j=0;j<2;j++){
//                    var cube = new NormalQube();
                    var cube = new AdvantageQube();
//                    var cube = new ForbiddenQube();
                    cube.x = i *margin  - 3;
                    cube.y = 0;
                    cube.z = j *margin;
                    scene.addChild(cube);
                    cubes.push(cube);//配列に組み込む
                    cubes.parentArray = cubes;//子から親が読めるようにしておく
                    //自動で回転イベント付与
//                    cube.roll(90,20);
                }
            }
        };

        //座標軸を生成
        var createAxis = function(){
//           var axis = new Axis(scene);
        }

        //床面を生成
        var createFloor = function(){
            var scale = 1;
            var margin = 2.0;
            var texture = new Texture();
            texture.src = bgImage;

            for(var i=0;i<4;i++){
                floors[i] = new Array();
                for(var j=0;j<14;j++){
                    var plane = new Floor(scale);
                    plane.x =  i * scale * margin - 3;
                    plane.y = -1;
                    plane.z =  j * scale * margin;
                    plane.arrayNumX = i;//配列上の位置を持たせる
                    plane.arrayNumY = j;
                    plane.parentArray = floors;
                    scene.addChild(plane);
                    floors[i].push(plane);
                }
            }
        }

        //プレイヤーモデルを生成
        var createPlayer = function(){
            player = new Player();
            //playerクラスの矩形当たり判定の取り方と一歩の間隔で
            //床面の境目に入り込むと判定に齟齬があるため、小数点座標に配置する
            player.x = 0.1;
            player.y = 1.1;
            player.z = 14;
            scene.addChild(player);
        }
//-----init UI
        //画面表示部品の生成関数をまとめる
        var initUI = function(){
            createScene3d();
            createCubes();
            createAxis();
            createFloor();
            createPlayer();
        };
//-----イベントコントロールハンドラ
        //動作タイミングの管理、キーイベント、フラグなどの管理イベントの生成
        var initHandler = function(){
            var time = 0; //キューブの回転タイミングを管理
            var enableDeleteCube = false; //[フラグ]回転停止時ごとに1度だけマーカー解除からキューブを削除できる(回転動作中に削除させない)
            var lestTimeCounter = 0;//何らかの演出などを処理している間は、新しい回転動作を行わない。

//-----キーイベントの生成
            game.keybind(90, 'a');// zキー  
		    game.keybind(88, 'b');// xキー  
		    game.keybind(67, 'c');// cキー  

            //プレイヤー操作時に、一度のボタン押下で一度だけ行う処理のためのフラグを生成するイベント
            game.addEventListener('abuttondown', function(){
                console.log("abuttondown");
            })
            game.addEventListener('abuttonup', function(){
                player.aButtonStack = 0;//初期化
                console.log("abuttonup");
            })

            game.addEventListener('bbuttondown', function(){
                console.log("bbuttondown");
            })

            game.addEventListener('bbuttonup', function(){
                player.bButtonStack = 0;
                console.log("bbuttonup");
            })


//-----毎フレーム行う処理
            game.rootScene.addEventListener('enterframe', function(){// game.addEventに書き換えるべき
                //プレイヤーの載っている床面を更新
                player.getStayFloor(floors);


                //15フレームに1度床面とキューブの走査を行う(密に行うほど精緻な判定になるが処理に影響する)(回転が停止し、enableが有効になるタイミング)
                if(time % 15 == 1){

                    //回転が止まったタイミングでキューブを消せる状態変数に置き換える
                    if(time % 15 == 1){
                        enableDeleteCube = true;
                        lestTimeCounter += 15;
                        time++;//ループを防ぐ
                    }

                    //各々の床面のキューブ積載状態を調べる
                    for(var i=0;i<floors.length;i++){
                        for(var j=0;j<floors[i].length;j++){
                            var isCarry = floors[i][j].checkOn(cubes);
                            //床面にキューブが載っていれば処理する
//                            if(isCarry){
//                                var cubeType = floors[i][j].targetCube.type;
//                                //積載判定が出たときの処理（マーカー解除時ではない、回転開始直前）
//                                switch(cubeType){
//                                    case 0:
//                                        //ノーマルキューブの処理
//                                        break;
//                                    case 1:
//                                        //ADVキューブの処理
//                                        break;
//                                    case 2:
//                                        //FBDキューブの処理
//                                        break;
//                                }
//                            }else{
//                            //床面キューブが載っていない処理（回転開始直前）
//                            }
                        }
                    }

                }

                //30フレームに1度回転処理を呼び出す
                if(time % 15 == 0 && (lestTimeCounter <= 0)){
                    //回転中はマーカー解除してもキューブを捕獲できない
                    enableDeleteCube = false;
                    //15フレームで90度回転させる指示を与える
                    for(var i=0;i<cubes.length;i++){
                        cubes[i].roll(90,15);
                    }

                }

                //削除演出中で無ければカウンタを回す
                if(lestTimeCounter <= 0){
                    time++;
                }else{
                    lestTimeCounter -= 1;
                }
            })
//-----カーソルキー入力へのアクション
        //プレイヤーのアクション
        //一度の押下で何度も行う処理
        player.addEventListener('enterframe', function(){
             if (game.input.left){
                this.x -= 1/5;
             };
             if (game.input.right){
                this.x += 1/5;
             };  
             if (game.input.up){
                this.z -= 1/5;
             };  
             if (game.input.down){
                this.z += 1/5;
             };

//-----ボタン入力へのアクション
    	     //z
             //一度の押下で一度だけ行う処理
		     if(game.input.a && (this.aButtonStack == 0) ){

                //マーカーをセットする
                 if(this.markedFloor == null){
                     //マーカーを貼った床面を保持する
                     this.markedFloor = this.stayFloor;
                     //床面にマーカーをセットする
                     this.stayFloor.isMarker = !this.stayFloor.isMarker;

                //マーカーを解除する
                 }else{
                    this.markedFloor.isMarker = !this.markedFloor.isMarker;//マークした床面をノーマークに戻す
                    //まだキューブを消していない、かつ、回転中でない
                    if(enableDeleteCube){
                        this.markedFloor.solveMarker(); //マーカー解除処理を呼ぶ

                        //マーカー解除した床面にキューブが載っていれば、処理を呼ぶ
                        if(this.markedFloor.targetCube != null){
//                            isDuringDeleting = true;//削除中フラグをたて、カウンタを回さない
                            lestTimeCounter =  30;//キューブを削除したら30フレーム待機してから次の回転を始める
                            //キューブが消えたらフラグを戻すイベントリスナを生成
                            this.markedFloor.targetCube.addEventListener('enterframe', function(){
                               if(this.y  > 90){
//                                    isDuringDeleting = false; //キューブが飛んでいったらフラグを終了（もっとうまい方法があるのでは）
//                                    isDuringDeleting = 0;
                                    this.removeEventListener('enterframe', arguments.callee);
                                }
                            })
                        }
                        enableDeleteCube = false;//一度の回転停止時のタイミングで、マーカー解除では複数回消せないようにしておく
                    }
                    this.markedFloor = null;//保持していた床面を破棄
                }

                 this.aButtonStack = 1;//フラグを進める
		     }
		     //ｘ
             //一度の押下で一度だけ行う処理
		     if(game.input.b && (this.bButtonStack == 0)&& (lestTimeCounter > 0) ){ //ボタン押下時で、一押下で一回起動するもので、回転まで時間がある
                //起爆マークがあるときにxボタンを押したとき
                //すべて床を走査して起爆マークのある床面を探す
                
                var markedFloors = new Array();
                
                for(var i=0;i<floors.length;i++){
                    for(var j=0;j<floors[i].length;j++){
                        //床面にマークがあった場合
                        if(floors[i][j].isAdvMarked){
                            console.log("AdvMark bomb");
                            floors[i][j].isAdvMarked = false; //繰り返し起爆しないためにフラグ解除
                            //周辺3x3に対してsolveMarkerを呼び出す
                            for(var k=0;k<3;k++){
                                if( (i+k-1)>-1  && (i+k-1)< floors.length){ //負のインデックスは呼ばない
                                    for(var l=0;l<3;l++){
                                        if( (i+k-1)>-1 && (j+l-1)>-1 ){ //負のインデックスは呼ばない
                                            if(floors[i+k-1][j+l-1] != undefined){ //床面が存在しなければ呼ばない

                                                markedFloors.push( floors[i+k-1][j+l-1] ); //起爆すべき床面の配列に格納する
//                                                floors[i+k-1][j+l-1].solveMarker();//マーカー解除と同様の処理を呼び出す
//                                                floors[i+k-1][j+l-1].isAdvMarked = false;//起爆マーカーを解除
                                            }
                                        }
                                    }
                                }
                            }
                        }
		            }
                }

                //格納された起爆する床面にsolveMarkerを呼び出す
                for(var i=0;i<markedFloors.length;i++){

                    markedFloors[i].solveMarker();
//                    markedFloors[i].isAdvMarked = false;
                }
                markedFloors = null;

                this.bButtonStack = 1; //フラグを進める
             }
        })
        }

//-----initialize
        //初期化処理をまとめて記述
        var initialize = function (){

            initUI();//画面部品を生成
            initHandler();//コントロール系のロジックを実行
        };
        initialize();
    }
    game.start();
}
</script>
<style type="text/css">
    body {
        margin: 0;
    }
</style>
<body>
</body>
</html>

